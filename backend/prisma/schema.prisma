generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
// Enums
//

enum Sector {
  MEDTECH
  FINTECH
  AI_INFRA
  SAAS
  HEALTHCARE
  CLIMATE
  CONSUMER
  INDUSTRIAL
  OTHER
}

enum InvestmentStatus {
  GREEN
  AMBER
  RED
}

enum InstrumentType {
  EQUITY
  SAFE
  CONVERTIBLE_NOTE
  OTHER
}

enum CashflowType {
  INVESTMENT
  FOLLOW_ON
  DISTRIBUTION
  FEE
  SECONDARY_BUY
  SECONDARY_SELL
  CONVERSION
  OTHER
}

enum ValuationMethod {
  ROUND_PRICED
  INTERNAL_MARK
  DCF
  MULTIPLE
  OTHER
}

enum DocumentType {
  PITCH_DECK
  FINANCIALS
  LEGAL
  BOARD_PACK
  DATA_ROOM
  OTHER
}

enum StorageProvider {
  S3
}

enum AttachmentTargetType {
  COMPANY
  INVESTMENT
  REVIEW_JOB
  FOUNDER_UPDATE
  NOTE
}

enum ReviewJobStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  FAILED
}

enum ActionSeverity {
  LOW
  MEDIUM
  HIGH
}

enum ActionStatus {
  OPEN
  IN_PROGRESS
  DONE
  CLOSED
}

enum ForecastSource {
  MANUAL
  AI_EXTRACTED
  FOUNDER_UPDATE
}

enum PeriodType {
  QUARTER
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

//
// Core
//

model User {
  id        String   @id @default(cuid())
  email     String?  @unique
  name      String?
  createdAt DateTime @default(now())

  // relations
  uploadedDocumentVersions DocumentVersion[]
  createdTermVersions      InvestmentTermsVersion[]
  statusEvents             StatusEvent[]
  auditLogs                AuditLog[]
}

model Company {
  id          String   @id @default(cuid())
  name        String
  sector      Sector   @default(OTHER)
  country     String?
  website     String?
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  investments Investment[]

  @@index([sector])
  @@unique([name])
}

model Investment {
  id            String            @id @default(cuid())
  companyId     String
  label         String?
  instrumentType InstrumentType   @default(OTHER)

  // latest-state dashboard fields
  status        InvestmentStatus  @default(GREEN)
  statusReason  String?
  ownershipPct  Decimal?          @db.Decimal(10, 6)
  entryValuation Decimal?         @db.Decimal(18, 2)
  currency      String?           // original currency if not EUR (e.g., "USD")

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  company       Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)

  cashflows     Cashflow[]
  valuationMarks ValuationMark[]
  termVersions  InvestmentTermsVersion[]
  statusEvents  StatusEvent[]
  actions       ActionRequired[]
  reviewJobs    ReviewJob[]
  forecastVersions ForecastVersion[]

  @@index([companyId])
  @@index([status])
}

//
// Versioning / append-only history
//

model InvestmentTermsVersion {
  id            String         @id @default(cuid())
  investmentId  String
  version       Int
  instrumentType InstrumentType
  ownershipPct  Decimal?       @db.Decimal(10, 6)
  entryValuation Decimal?      @db.Decimal(18, 2)
  rationale     String?
  createdAt     DateTime       @default(now())
  createdByUserId String?

  investment    Investment     @relation(fields: [investmentId], references: [id], onDelete: Cascade)
  createdBy     User?          @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@unique([investmentId, version])
  @@index([investmentId, createdAt])
}

model Cashflow {
  id            String       @id @default(cuid())
  investmentId  String
  date          DateTime
  type          CashflowType
  // Convention: negative = cash out, positive = cash in
  amount        Decimal      @db.Decimal(18, 2)
  currency      String       // e.g., "EUR", "USD"

  // FX snapshot to EUR (store even if EUR, use 1.0)
  fxRateToEUR   Decimal      @db.Decimal(18, 8)
  fxSource      String?
  fxTimestamp   DateTime?

  note          String?
  createdAt     DateTime     @default(now())

  investment    Investment   @relation(fields: [investmentId], references: [id], onDelete: Cascade)

  @@index([investmentId, date])
  @@index([type])
}

model ValuationMark {
  id            String         @id @default(cuid())
  investmentId  String
  asOfDate      DateTime
  method        ValuationMethod
  source        String?
  confidence    Decimal?       @db.Decimal(4, 3)

  // Store in original currency plus FX snapshot and derived EUR (fast reporting)
  value         Decimal        @db.Decimal(18, 2)
  currency      String         // "EUR", "USD", etc.
  fxRateToEUR   Decimal        @db.Decimal(18, 8)
  valueEUR      Decimal        @db.Decimal(18, 2)

  createdAt     DateTime       @default(now())

  investment    Investment     @relation(fields: [investmentId], references: [id], onDelete: Cascade)

  @@index([investmentId, asOfDate])
  @@index([method])
}

model StatusEvent {
  id            String           @id @default(cuid())
  investmentId  String
  fromStatus    InvestmentStatus
  toStatus      InvestmentStatus
  reason        String?
  createdAt     DateTime         @default(now())
  createdByUserId String?

  investment    Investment       @relation(fields: [investmentId], references: [id], onDelete: Cascade)
  createdBy     User?            @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@index([investmentId, createdAt])
}

//
// Actions
//

model ActionRequired {
  id            String         @id @default(cuid())
  investmentId  String
  reviewJobId   String?
  extractedFactId String?

  title         String
  description   String?
  severity      ActionSeverity @default(MEDIUM)
  owner         String         // single-user MVP; later FK
  dueDate       DateTime?
  status        ActionStatus   @default(OPEN)
  resolutionNote String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  closedAt      DateTime?

  investment    Investment     @relation(fields: [investmentId], references: [id], onDelete: Cascade)
  reviewJob     ReviewJob?     @relation(fields: [reviewJobId], references: [id], onDelete: SetNull)
  extractedFact ExtractedFact? @relation(fields: [extractedFactId], references: [id], onDelete: SetNull)

  @@index([investmentId, status])
  @@index([dueDate])
}

//
// Documents: logical doc + append-only versions + attach-to-anything
//

model Document {
  id        String       @id @default(cuid())
  title     String?
  docType   DocumentType @default(OTHER)
  createdAt DateTime     @default(now())

  versions  DocumentVersion[]
  attachments DocumentAttachment[]

  @@index([docType])
}

model DocumentVersion {
  id            String          @id @default(cuid())
  documentId    String
  version       Int

  fileName      String
  mimeType      String
  sizeBytes     BigInt
  checksum      String

  storageProvider StorageProvider @default(S3)
  storageKey     String
  pageCount      Int?

  uploadedAt     DateTime        @default(now())
  uploadedByUserId String?

  document      Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)
  uploadedBy    User?            @relation(fields: [uploadedByUserId], references: [id], onDelete: SetNull)

  reviewJobLinks ReviewJobDocument[]
  extractedFacts ExtractedFact[]

  @@unique([documentId, version])
  @@index([checksum])
}

model DocumentAttachment {
  id           String               @id @default(cuid())
  documentId   String
  targetType   AttachmentTargetType
  targetId     String               // polymorphic target reference
  createdAt    DateTime             @default(now())

  document     Document             @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([targetType, targetId])
  @@index([documentId])
}

//
// Reviews: job + join table to specific doc versions + structured facts
//

model ReviewJob {
  id             String         @id @default(cuid())
  investmentId   String
  status         ReviewJobStatus @default(QUEUED)

  promptVersion  String
  idempotencyKey String         @unique

  resultJson     Json?
  error          String?

  retryCount     Int            @default(0)
  createdAt      DateTime       @default(now())
  startedAt      DateTime?
  finishedAt     DateTime?

  investment     Investment     @relation(fields: [investmentId], references: [id], onDelete: Cascade)

  documents      ReviewJobDocument[]
  extractedFacts ExtractedFact[]
  actions        ActionRequired[]

  @@index([investmentId, status])
  @@index([createdAt])
}

model ReviewJobDocument {
  id               String          @id @default(cuid())
  reviewJobId      String
  documentVersionId String

  reviewJob        ReviewJob       @relation(fields: [reviewJobId], references: [id], onDelete: Cascade)
  documentVersion  DocumentVersion @relation(fields: [documentVersionId], references: [id], onDelete: Cascade)

  @@unique([reviewJobId, documentVersionId])
  @@index([documentVersionId])
}

model ExtractedFact {
  id              String          @id @default(cuid())
  reviewJobId     String
  documentVersionId String?

  // flexible typing
  factType        String          // e.g., "RUNWAY_MONTHS", "MRR", "RISK"
  key             String?
  valueString     String?
  valueNumber     Decimal?        @db.Decimal(18, 6)
  valueJson       Json?
  confidence      Decimal?        @db.Decimal(4, 3)
  citation        String?         // "Slide 12", "Page 3", etc.
  createdAt       DateTime        @default(now())

  reviewJob       ReviewJob       @relation(fields: [reviewJobId], references: [id], onDelete: Cascade)
  documentVersion DocumentVersion? @relation(fields: [documentVersionId], references: [id], onDelete: SetNull)

  actions         ActionRequired[]

  @@index([reviewJobId])
  @@index([factType])
}

//
// Forecasts: append-only versions + quarterly lines
//

model ForecastVersion {
  id            String         @id @default(cuid())
  investmentId  String
  version       Int
  isCurrent     Boolean        @default(false)
  source        ForecastSource @default(MANUAL)
  createdAt     DateTime       @default(now())

  investment    Investment     @relation(fields: [investmentId], references: [id], onDelete: Cascade)
  lines         ForecastLine[]

  @@unique([investmentId, version])
  @@index([investmentId, isCurrent])
}

model ForecastLine {
  id               String     @id @default(cuid())
  forecastVersionId String
  periodStart      DateTime
  periodType       PeriodType @default(QUARTER)
  currency         String?    // optional

  revenue          Decimal?   @db.Decimal(18, 2)
  cogs             Decimal?   @db.Decimal(18, 2)
  opex             Decimal?   @db.Decimal(18, 2)
  ebitda           Decimal?   @db.Decimal(18, 2)
  cash             Decimal?   @db.Decimal(18, 2)
  headcount        Int?
  burn             Decimal?   @db.Decimal(18, 2)

  forecastVersion  ForecastVersion @relation(fields: [forecastVersionId], references: [id], onDelete: Cascade)

  @@index([forecastVersionId, periodStart])
}

//
// Notes / Founder updates (append-only) â€“ minimal MVP
//

model Note {
  id          String   @id @default(cuid())
  investmentId String?
  companyId    String?
  content     String
  createdAt   DateTime @default(now())

  @@index([investmentId])
  @@index([companyId])
}

model FounderUpdate {
  id          String   @id @default(cuid())
  companyId   String
  title       String?
  content     String
  createdAt   DateTime @default(now())

  @@index([companyId, createdAt])
}

//
// Audit log (append-only)
//

model AuditLog {
  id            String      @id @default(cuid())
  entityType    String
  entityId      String
  action        AuditAction
  changedFields Json?
  rationale     String?
  createdAt     DateTime    @default(now())
  createdByUserId String?

  createdBy     User?       @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([createdAt])
}
